#!/usr/bin/env python
from __future__ import print_function

__author__ = "James Jackson"
__copyright__ = "Copyright 2017, ROSflight"
__license__ = "BSD-3"
__version__ = "0.1"
__maintainer__ = "James Jackson"
__email__ = "superjax08@gmail.com"

import time
import rospy
import smtplib
import numpy
import subprocess
import csv
import atexit
from enum import Enum
from email.MIMEMultipart import MIMEMultipart
from email.MIMEText import MIMEText
import sys
from sensor_msgs.msg import Imu, MagneticField
from rosflight_msgs.msg import Attitude, Barometer, OutputRaw, RCRaw, Status, Airspeed

RST  = "\x1B[0m"
KRED  = "\x1B[31m"
KMAG  = "\x1B[35m"
KGRN  = "\x1B[32m"
KYEL  = "\x1B[33m"
KBLU  = "\x1B[34m"

BOLD = "\x1B[1m"
UNDL = "\x1B[4m"

CLEAR = "\x1b[2K\r"
UPLINE = "\033[F"
STARTLINE = "\r"
END = "\x1b[200C"
CLEAR_SCREEN = "\033[2J + \033[0;0f"
def GO_UP(x): return "\x1b[" + str(x) + "A"


def GO_FORWARD(x): return "\033[" + str(x) + "C"

class MessageLevel(Enum):
    INFO = 1
    WARN = 2
    ERROR = 3
    FATAL = 4
    DEBUG = 5

# This constant tells the Message class to print a full date and time with each message
# You should not need to modify this value
USE_DATETIME = -1

class Message():
    def __init__(self, message, level, t=USE_DATETIME):
        self.msg = message
        self.lvl = level
        self.timeString = time.strftime("%Y:%m:%d %H:%M:%S") if t == USE_DATETIME else '{:.3f}'.format(t)

    def __str__(self):        
        string = RST + "[ " + self.timeString + " ] - "
        if self.lvl == MessageLevel.INFO:
            string += self.msg
        elif self.lvl == MessageLevel.WARN:
            string += KYEL + self.msg + RST
        elif self.lvl == MessageLevel.ERROR:
            string += KRED + self.msg + RST
        elif self.lvl == MessageLevel.FATAL:
            string += BOLD + KRED + self.msg + RST
        elif self.lvl == MessageLevel.DEBUG:
            string += KBLU + self.msg + RST
        return string

    def __repr__(self):
        return self.__str__()

class State(Enum):
    INIT = 0
    GOOD = 1
    STALLED = 2
    OUTLIER = 3
    ERROR = 4

MAX_OUTLIER_DURATION = 5.0 # if a sensor consistently produces outlier values for longer than this time, an error will be produced
STALL_TIME = 1.0 # if the time elapsed between two messages is more than STALL_TIME, state machine goes to STALL state

# dataset size for the standard deviation
STD_SAMPLE_SIZE = 500
Z = 5 # values more than z standard deviations from the mean will be considered outliers

# return values for oulier checking function
NO_OUTLIERS = 0
OUTLIER_DETECTED = 1

class Stats():
    def __init__(self, size, name, check_outliers=True, csvfile=False, software_sim=False):
        self.max = [0.0 for i in range(size)]
        self.min = [1e9 for i in range(size)]
        self.t_diff = 0.0
        self.last_t = 0.0
        self.last_val = [0.0 for i in range(size)]
        self.data = {'t': [], 'val': []}
        self.name = name
        self.currentState = State.INIT
        self.lastState = State.INIT
        self.std_dataset = []
        self.std = [] # standard deviation
        self.mean = [0.0 for i in range(size)] # mean value
        self.upper_bound = [] # upper bound for acceptible values
        self.lower_bound = [] # lower bound for acceptible values
        self.check_for_outliers = check_outliers
        self.outlier_start_time = 0
        self.outlier_duration = 0

        self.software_sim = software_sim
        self.start = time.time() if not software_sim else 0.0
        self.printDebug = True if self.software_sim else False

        self.m = [0 for i in range(size)]
        self.s = [0 for i in range(size)]
        self.k = [0 for i in range(size)]
        self.var = [0 for i in range(size)]

    def write_csv(self, fields=None):
        file = open('%s.csv' % self.name, 'wb')
        spreadsheet = csv.writer(file, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
        # write column headers
        spreadsheet.writerow(['Data'] + [''] * len(fields) + ['Lower bound'] + [''] * (len(fields) - 1) + ['Upper bound'])
        spreadsheet.writerow(['Time'] + fields * 3)

        # write data
    
    # wrapper function for sending messages
    # Allows printing elapsed time or full date and time without having a conditional in every call to Message()
    def messageWrapper(self, message, level):
        if self.software_sim:
            return Message(message, level, t=self.last_t)
        else:
            return Message(message, level)

    # returns true if the last data point recorded is an outlier, false otherwise
    def is_outlier(self, val):
        # return false if there is not enough data to reasonably identify outliers
        if not len(self.data['val']) > STD_SAMPLE_SIZE:
            return False

        # return false if outlier checking is disabled
        if self.check_for_outliers == False:
            return False

        for (v, upper, lower) in zip(val, self.upper_bound[-1], self.lower_bound[-1]):
            if v > upper or v < lower: return True
        return False

    def update(self, val, t, fields=None):
        if fields is not None:
            val = [getattr(val, field) for field in fields]
            # print("getting vals from fields")
        elif not isinstance(val, list):
            val = [val]
        elif isinstance(val,list):
            val = val[:8]
        
        # update last_val and last_t no matter what
        self.last_val = val
        self.t_diff = t - self.last_t
        self.last_t = t

        # variables used by all states
        currentTime = t if self.software_sim else time.time()
        elapsedTime = currentTime - self.start
        timeString = '{:.3f}'.format(elapsedTime) if self.software_sim else time.strftime("%H:%M:%S", time.gmtime(elapsedTime))

        # update state
        if self.currentState == State.INIT:
            print(self.messageWrapper(self.name + " found", MessageLevel.INFO))
            self.currentState = State.GOOD

        elif self.currentState == State.GOOD:
            if not (self.t_diff < STALL_TIME) and not self.is_outlier(val): # check for stall condition
                print(self.messageWrapper(self.name + " stalled out after running for " + timeString, MessageLevel.WARN))
                self.currentState = State.STALLED
            elif self.is_outlier(val): # check for outlier condition
                self.currentState = State.OUTLIER
                self.outlier_start_time = t

        elif self.currentState == State.STALLED:
            if self.t_diff < STALL_TIME: # t_diff < STALL_TIME means we got new data
                if not self.is_outlier(val): # check outlier before going back to good
                    self.currentState = State.GOOD
                    print(self.messageWrapper(self.name + " recovered", MessageLevel.INFO))
                else:
                    self.currentState = State.OUTLIER
                    self.outlier_start_time = t

        elif self.currentState == State.OUTLIER:
            if self.is_outlier(val): # new val is outlier
                self.outlier_duration = t - self.outlier_start_time # figure out how long we have been in outlier state
                if not (self.outlier_duration < MAX_OUTLIER_DURATION): # stuck in outlier state. something is probably wrong
                    self.currentState = State.ERROR
                    
                    # strings for the output message
                    if self.software_sim:
                        startString = '{:.3f}'.format(self.outlier_start_time)
                        endString =  '{:.3f}'.format(currentTime)
                    else:
                        startString = time.strftime("%H:%M:%S", time.gmtime(self.outlier_start_time))
                        endString = time.strftime("%H:%M:%S", time.gmtime(currentTime))
                    
                    err_msg = " errored out due to outliers after running for {runtime}. Outlier period started at {start} and ended at {end} ({:.3f})".format(
                        self.outlier_duration, runtime=timeString, start=startString, end=endString)

                    # report the problem
                    print(self.messageWrapper(self.name + err_msg, MessageLevel.ERROR))

    
            else: # new val is not outlier
                print(self.messageWrapper(self.name + " recovered from outlier after {:.3f} seconds".format(self.outlier_duration), MessageLevel.INFO))
                if self.t_diff < STALL_TIME:
                    self.currentState = State.GOOD
                else: # stall
                    self.currentState = State.STALLED
                    print(self.messageWrapper(self.name + " stalled out after running for " + timeString, MessageLevel.WARN))
                

        # perform state actions
        # don't add new values to the dataset while in the outlier state
        if self.currentState != State.OUTLIER:
            if self.check_for_outliers and len(self.data['val']) > 0:
                # index for standard deviation starts at 0 if total dataset size is less than sample size
                # otherwise find the standard deviation of the last STD_SAMPLE_SIZE points
                start_index = 0 if (len(self.data['val']) < STD_SAMPLE_SIZE) else -STD_SAMPLE_SIZE
                arr = numpy.array(self.data['val'][start_index:])
                self.std = numpy.std(arr, axis=0)
                self.mean = numpy.mean(arr, axis=0)
                lb = self.mean - Z * self.std
                ub = self.mean + Z * self.std
                self.lower_bound.append(lb.tolist())
                self.upper_bound.append(ub.tolist())
            
            self.max = [max(internal, new) for internal, new in zip(self.max, val)]
            self.min = [min(internal, new) for internal, new in zip(self.max, val)]
            self.data['t'].append(t)
            self.data['val'].append(val) # newest value is at end of array, oldest at beginning


            if len(self.data['val']) > 10240:
                # pop oldest value
                self.data['val'].pop(0)
                self.data['t'].pop(0)
                self.lower_bound.pop(0)
                self.upper_bound.pop(0)

        if self.printDebug:
            self.stateDebug()
        
    def stateDebug(self):
        if self.currentState != self.lastState:
            print(self.messageWrapper("State transition: {old} -> {new}".format(old=self.lastState, new=self.currentState), MessageLevel.DEBUG))
            self.lastState = self.currentState


MAX_LOOP_TIME_US = 1000
MAX_ERROR_COUNT = 3

gitHashCmd = "git rev-parse --short HEAD"
gitBranchCmd = "git branch"

class Tester():
    def __init__(self):
        # self.acc = Stats(3, 'acc')
        # self.gyro = Stats(3, 'gyro')
        # self.mag = Stats(3, 'mag')
        self.att = Stats(4, 'att', csvfile=True)
        # self.omega = Stats(3, 'omega')
        # self.airspeed = Stats(1, 'airspeed')
        # self.baro = Stats(1, 'baro')
        # self.output = Stats(8, 'output')
        # self.rc = Stats(8, 'rc')
        # self.status = Stats(2, 'status', check_outliers=False)

        self.stats_list = [key for key in self.__dict__.keys() if "__" not in key]

        self.error_list = { 'stat' : [], 'message' : []}
        self.error_count = 0

        self.last_time = time.time()
        print(CLEAR_SCREEN, end='')
        print("===========  ROSFLIGHT HARDWARE CONTINUOUS INTEGRATION TEST ===========\n\n")
        print(Message("Start Test", MessageLevel.INFO))

        self.run()


    def imu_callback(self, msg):
        t = msg.header.stamp.to_sec()
        if hasattr(self, 'acc'): self.acc.update(msg.linear_acceleration, t, fields=['x', 'y', 'z'])
        if hasattr(self, 'acc'): self.gyro.update(msg.angular_velocity, t, fields=['x', 'y', 'z'])

    def mag_callback(self, msg):
        t = msg.header.stamp.to_sec()
        if hasattr(self, 'mag'): self.mag.update(msg.magnetic_field, t, fields=['x','y','z'])

    def att_callback(self, msg):
        t = msg.header.stamp.to_sec()
        if hasattr(self, 'att'): self.att.update(msg.attitude, t, fields=['w','x','y','z'])
        if hasattr(self, 'omega'): self.omega.update(msg.angular_velocity, t, fields=['x', 'y', 'z']) # 

    def baro_callback(self, msg):
        t = msg.header.stamp.to_sec()
        if hasattr(self, 'baro'): self.baro.update([msg.pressure], t)

    def airspeed_callback(self, msg):
        t = msg.header.stamp.to_sec()
        if hasattr(self, 'airspeed'): self.airspeed.update(msg.differential_pressure, t)

    def output_callback(self, msg):
        t = msg.header.stamp.to_sec()
        if hasattr(self, 'output'): self.output.update(list(msg.values), t)

    def rc_callback(self, msg):
        t = msg.header.stamp.to_sec()
        if hasattr(self, 'rc'): self.rc.update(list(msg.values), t)

    def status_callback(self, msg):
        t = msg.header.stamp.to_sec()
        if hasattr(self, 'status'): self.status.update(msg, t, fields=['num_errors', 'loop_time_us'])

    def print_progress(self):
        if not hasattr(self, 'start_time'):
            self.start_time = time.time()
            self.progress_index = 1
        progress_indicator = ['_', 'o', 'O', '0', 'O', 'o']
        if time.time() > (self.start_time + 0.12 * self.progress_index):
            self.progress_index += 1
            print(END + '%s%c%s' % (KGRN, progress_indicator[self.progress_index % len(progress_indicator)], RST),
                  end='\r')

    def got_msg(self, type):
        if hasattr(self, type) and len(getattr(self, type).data['val']) > 0:
            return True
        else:
            return False

    def print_status(self, type):
        if self.got_msg(type):
            print(RST+CLEAR, end='')

            # lower bound
            string = type + "\r" + GO_FORWARD(8) + " -- | lower bound   \t| ["
            values = []
            for i, val in enumerate(getattr(self, type).lower_bound[-1]):
                string += "{:10.4f}"
                values.append(val)
                if i != len(getattr(self, type).last_val) - 1:
                    string += ", "
            string += "]"

            # last_val
            string += "\n" + type + "\r" + GO_FORWARD(8) + " -- | dt = {:10.6f} \t| ["
            values.append(getattr(self,type).t_diff)
            for i, val in enumerate(getattr(self, type).last_val):
                string += "{:10.4f}"
                values.append(val)
                if i != len(getattr(self, type).last_val) - 1:
                    string += ", "
            string += "]"
            
            # display if each field is within range, over range, or under range
            range = " | [ "
            for i, (val, upper, lower) in enumerate(zip(getattr(self, type).last_val, getattr(self, type).upper_bound[-1], getattr(self, type).lower_bound[-1])):
                if val > upper:
                    range += "over range"
                elif val < upper and val > lower:
                    range += "in range"
                else:
                    range += "under range"
                if i != len(getattr(self, type).last_val) - 1:
                    range += ", "
            range += " ]"
            string += range
            
            # upper bound
            string += "\n" + type + "\r" + GO_FORWARD(8) + " -- | upper bound   \t| ["
            for i, val in enumerate(getattr(self, type).upper_bound[-1]):
                string += "{:10.4f}"
                values.append(val)
                if i != len(getattr(self, type).last_val) -1:
                    string += ", "
            string += "]"

            # string += " | State: %d" % getattr(self, type).state

            print(string.format(*values), end='\n')
            return 1
        else:
            return 0
    
    def send_email(self, stat, message):
        # # read email credentials from the credentials file
        # credentials = open('credentials', 'r')
        # email = credentials.readline()
        # email = email.rstrip() # remove the trailing \n
        # password = credentials.readline()
        # credentials.close()

        # server = smtplib.SMTP('smtp.gmail.com', 587)
        # server.ehlo()
        # server.starttls()
        # server.ehlo()

        # server.login(email, password)

        # fromaddr = email
        # toaddr = "cameron.mcquinn@gmail.com"
        # msg = MIMEMultipart()
        # msg['From'] = fromaddr
        # msg['To'] = toaddr
        # msg['Subject'] = "Rosflight Hardware CI Failed"
        elapsedTime = time.gmtime(time.time() - getattr(self, stat).start)
        # commitHash = subprocess.check_output(gitHashCmd.split())
        # commitHash = commitHash.rstrip() # remove trailing \n
        # branchCmdOutput = subprocess.check_output(gitBranchCmd.split())
        # currentBranchMarker = "* "
        # startPos = branchCmdOutput.find(currentBranchMarker) + len(currentBranchMarker)
        # endPos = branchCmdOutput.find("\n")
        # branchName = branchCmdOutput[startPos:endPos].rstrip()
        print(CLEAR_SCREEN, end='')
        print("===========  ROSFLIGHT HARDWARE CONTINUOUS INTEGRATION TEST ===========\n\n")
        body = stat + " " + message + " after running for " + time.strftime("%H:%M:%S", elapsedTime) + ".  "
        body += "\n"
        values = []
        
        body += "Mean: [ "
        for i, val in enumerate(getattr(self, stat).mean):
            body += "{:8.6f}"
            values.append(val)
            if i != len(getattr(self, stat).mean) - 1:
                body += ", "
        body += " ]\n"

        body += "Upper bound:  [ "
        for i, val in enumerate(getattr(self, stat).upper_bound):
            body += "{:8.6f}"
            values.append(val)
            if i != len(getattr(self, stat).upper_bound) - 1:
                body += ", "
        body += " ]\n"

        body += "Last value:   [ "
        for i, val in enumerate(getattr(self, stat).last_val):
            body += "{:8.6f}"
            values.append(val)
            if i != len(getattr(self, stat).last_val) -1:
                body += ", "
        body += " ]\n"

        range = "Bounds check: [ "
        for i, (val, upper, lower) in enumerate(zip(getattr(self, stat).last_val,getattr(self, stat).upper_bound,getattr(self, stat).lower_bound)):
            strlen = len("{:8.6f}".format(val))
            if val > upper:
                range += "{:{width}}".format("over", width=strlen)
            elif val < upper and val > lower:
                range += "{:{width}}".format("in range", width=strlen)
            else:
                range += "{:{width}}".format("under", width=strlen)
            if i != len(getattr(self, stat).last_val) - 1:
                range += ", "
        range += " ]\n"
        body += range

        body += "Lower bound:  [ "
        for i, val in enumerate(getattr(self, stat).lower_bound):
            body += "{:8.6f}"
            values.append(val)
            if i != len(getattr(self, stat).lower_bound) - 1:
                body += ", "
        body += " ]\n"

        print(body.format(*values), end='\n')
        # body += "Rosflight commit " + commitHash + " on branch " + branchName + ".  "
        # body += "Now go fix it!"
        # body += "\n\nSincerely,\nthe Rosflight bot"
        # msg.attach(MIMEText(body, 'plain'))

        # # send message
        # text = msg.as_string()
        # server.sendmail(fromaddr, toaddr, text)
        # server.close()
        print("DANGER WILL ROBINSON!!")

    def handle_error(self, stat, message):
        self.error_list['stat'].append(stat)
        self.error_list['message'].append(message)
        error = "Error detected on " + stat
        print(error)
        self.error_count += 1

    def check_for_error(self):
        # check loop time
        if getattr(self, 'status').last_val[1] > MAX_LOOP_TIME_US:
            self.handle_error('status', 'loop_time exceeded %duS' % MAX_LOOP_TIME_US)
            # self.send_email('status', 'loop_time exceeded %duS' % MAX_LOOP_TIME_US)

        # loop through the stats objects and check the state of each one
        for stat in self.stats_list:
            # check for stalled stats
            if getattr(self,stat).state == State.STALLED:
                # send an email notification that a stall occurred
                # self.send_email(stat, "stalled")
                self.handle_error(stat, "stalled")
            # check for outliers
            elif getattr(self,stat).state == State.OUTLIER:
                # send an email notification that an outlier was found
                # self.send_email(stat, "detected outlier")
                self.handle_error(stat, "detected outlier")
            

    def render(self):
        if time.time() > self.last_time + 0.03333:
            self.last_time = time.time()
            print("                                                                                                     ", end='')
            self.print_progress() # bouncy thing
            print("\n" + RST + CLEAR, end='\n')
            lines = 3
            lines += self.print_status('acc')
            lines += self.print_status('gyro')
            lines += self.print_status('mag')
            lines += self.print_status('att')
            lines += self.print_status('omega')
            #lines += self.print_status('airspeed')
            #lines += self.print_status('baro')
            #lines += self.print_status('output')
            #lines += self.print_status('rc')
            lines += self.print_status('status')
            print('\n', end='')
            print(RST + CLEAR, end='')
            print(GO_UP(lines), end='\r')

    def run(self):

        rospy.init_node("rosflight_hardware_test")
        self.att_sub = rospy.Subscriber('attitude', Attitude, self.att_callback)
        self.status_sub = rospy.Subscriber('status', Status, self.status_callback)
        self.rc_sub = rospy.Subscriber('rc_raw', RCRaw, self.rc_callback)
        self.output_sub = rospy.Subscriber('output_raw', OutputRaw, self.output_callback)
        self.baro_sub = rospy.Subscriber('baro', Barometer, self.baro_callback)
        self.mag_sub = rospy.Subscriber('mag', MagneticField, self.mag_callback)
        self.acc_sub = rospy.Subscriber('imu/data', Imu, self.imu_callback)
        self.pitot_sub = rospy.Subscriber('airspeed', Airspeed, self.airspeed_callback)

        start_time = time.time()

        while not rospy.is_shutdown() and self.error_count < MAX_ERROR_COUNT:
            # self.check_for_error()
            self.render()

        for stat in self.stats_list:
            if stat.file:
                stat.file.close()

        # print(CLEAR_SCREEN, end='')
        # print("Test terminated after %d errors" % MAX_ERROR_COUNT)

        # print(self.error_list.items())

        # for (stat, message) in zip(self.error_list['stat'], self.error_list['message']):
        #     error = stat + ": " + message
        #     print(error)







if __name__ == '__main__':
    tester = Tester()
