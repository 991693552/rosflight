#!/usr/bin/env python
from __future__ import print_function

__author__ = "James Jackson"
__copyright__ = "Copyright 2017, ROSflight"
__license__ = "BSD-3"
__version__ = "0.1"
__maintainer__ = "James Jackson"
__email__ = "superjax08@gmail.com"

import time
import rospy
import smtplib
import numpy
import subprocess
from email.MIMEMultipart import MIMEMultipart
from email.MIMEText import MIMEText
import sys
from sensor_msgs.msg import Imu, MagneticField
from rosflight_msgs.msg import Attitude, Barometer, OutputRaw, RCRaw, Status, Airspeed

RST  = "\x1B[0m"
KRED  = "\x1B[31m"
KMAG  = "\x1B[35m"
KGRN  = "\x1B[32m"
KYEL  = "\x1B[33m"
KBLU  = "\x1B[34m"

BOLD = "\x1B[1m"
UNDL = "\x1B[4m"

CLEAR = "\x1b[2K\r"
UPLINE = "\033[F"
STARTLINE = "\r"
END = "\x1b[200C"
CLEAR_SCREEN = "\033[2J + \033[0;0f"
def GO_UP(x): return "\x1b[" + str(x) + "A"


def GO_FORWARD(x): return "\033[" + str(x) + "C"

MSG_INFO = 1
MSG_WARN = 1
MSG_ERROR = 2
MSG_FATAL = 3

class Message():
    def __init__(self, message, level):
        self.msg = message
        self.lvl = level

    def __str__(self):
        date_string = time.strftime("%Y:%m:%d %H:%M:%S")
        string = RST + "[ " + date_string + " ] - "
        if self.lvl == MSG_INFO:
            string += self.msg
        elif self.lvl == MSG_WARN:
            string += KYEL + self.msg + RST
        elif self.lvl == MSG_ERROR:
            string += KRED + self.msg + RST
        elif self.lvl == MSG_FATAL:
            string += BOLD + KRED + self.msg + RST
        return string

    def __repr__(self):
        return self.__str__()

INIT = 0
GOOD = 1
STALLED = 2
OUTLIER = 3
ERROR = 4

MAX_OUTLIER_DURATION = 5.0 # if a sensor consistently produces outlier values for longer than this time, an error will be produced

# dataset size for the standard deviation
STD_SAMPLE_SIZE = 500
Z = 5 # values more than z standard deviations from the mean will be considered outliers

# return values for oulier checking function
NO_OUTLIERS = 0
OUTLIER_DETECTED = 1

class Stats():
    def __init__(self, size, name, check_outliers=True):
        self.max = [0.0 for i in range(size)]
        self.min = [1e9 for i in range(size)]
        self.t_diff = 0.0
        self.last_t = 0.0
        self.last_val = [0.0 for i in range(size)]
        self.data = {'t': [], 'val': []}
        self.name = name
        self.start = time.time()
        self.state = INIT
        self.std_dataset = []
        self.std = [0.0 for i in range(size)] # standard deviation
        self.mean = [0.0 for i in range(size)] # mean value
        self.upper_bound = [0.0 for i in range(size)] # upper bound for acceptible values
        self.lower_bound = [0.0 for i in range(size)] # lower bound for acceptible values
        self.check_for_outliers = check_outliers
        self.outlier_start_time = 0

        self.m = [0 for i in range(size)]
        self.s = [0 for i in range(size)]
        self.k = [0 for i in range(size)]
        self.var = [0 for i in range(size)]

    # returns true if the last data point recorded is an outlier, false otherwise
    def is_outlier(self, val, fields=None):
        # return false if there is not enough data to reasonably identify outliers
        if not len(self.data['val']) > STD_SAMPLE_SIZE:
            return False

        # return false if outlier checking is disabled
        if self.check_for_outliers == False:
            return False

        # extract data from the rosmsg
        if fields is not None:
            val = [getattr(val, field) for field in fields]
        elif not isinstance(val, list):
            val = [val]
        elif isinstance(val,list):
            val = val[:8]

        retval = False
        for (v, upper, lower) in zip(val, self.upper_bound, self.lower_bound):
            retval = True if v > upper or v < lower else retval
        return retval

    # def update(self, val, t, fields=None):
    #     if val != self.last_val:
    #         self.last_val = val
    #         self.last_t = t
    #     self.t_diff = t - self.last_t

    #     # update state
    #     if self.state == INIT:
    #         print(Message(self.name + " found", MSG_INFO))
    #         self.state = GOOD
    #     elif self.state == GOOD and self.t_diff > 1.0:
    #         elapsedTime = time.time() - self.start
    #         print(Message(self.name + " stalled out after running for " + time.strftime("%H:%M:%S", time.gmtime(elapsedTime)), MSG_ERROR))
    #         self.state = STALLED
    #     # do outlier checking
    #     elif self.state == GOOD and self.is_outlier(val, fields):
    #         self.state = OUTLIER
    #         self.outlier_start_time = t
    #     elif self.state == OUTLIER and not self.is_outlier(val, fields) and (t - self.outlier_start_time()) < 1.0:
    #         print(Message(self.name + " recovered", MSG_INFO))
    #         self.state = GOOD
    #     # go to ERROR state if OUTLIER state lasts more than MAX_OUTLIER_DURATION
    #     elif self.state == OUTLIER and (t - self.outlier_start_time) > MAX_OUTLIER_DURATION:
    #         self.state = ERROR
    #         elapsedTime = time.time() - self.start
    #         timeString = time.strftime("%H:%M:%S", time.gmtime(elapsedTime))
    #         durationString = time.strftime("%S", time.gmtime(t - self.outlier_start_time))
    #         print(Message(self.name + " detected an outlier after running for " + timeString + ". Outlier period lasted for " + durationString + " seconds", MSG_ERROR))
    #     elif self.state == STALLED and self.t_diff < 1.0:
    #         print(Message(self.name + " recovered", MSG_INFO))
    #         self.state = GOOD

    #     # perform state actions
    #     if self.state != OUTLIER:
    #         # update standard deviation and mean before the new values are added
    #         # this way, if the new value is an outlier, it will be easier to detect because it has not skewed our statistics
    #         if self.check_for_outliers and len(self.data['val']) > 5:
    #             # index for standard deviation starts at 0 if total dataset size is less than sample size
    #             # otherwise find the standard deviation of the last STD_SAMPLE_SIZE points
    #             start_index = 0 if (len(self.data['val']) < STD_SAMPLE_SIZE) else -STD_SAMPLE_SIZE
    #             arr = numpy.array(self.data['val'][start_index:])
    #             self.std = numpy.std(arr, axis=0)
    #             self.mean = numpy.mean(arr, axis=0)
    #             self.lower_bound = self.mean - Z * self.std
    #             self.upper_bound = self.mean + Z * self.std

    #         if fields is not None:
    #             val = [getattr(val, field) for field in fields]
    #         elif not isinstance(val, list):
    #             val = [val]
    #         elif isinstance(val,list):
    #             val = val[:8]
    #         self.max = [max(internal, new) for internal, new in zip(self.max, val)]
    #         self.min = [min(internal, new) for internal, new in zip(self.max, val)]
    #         self.data['t'].append(t)
    #         self.data['val'].append(val)

    #         if len(self.data['val']) > 10240:
    #             self.data['val'].pop(0)
    #             self.data['t'].pop(0)

    def update(self, val, t, fields=None):
        if val != self.last_val:
            self.last_val = val
            self.last_t = t
        self.t_diff = t - self.last_t

        # update state
        if self.state == INIT:
            print(Message(self.name + " found", MSG_INFO))
            self.state = GOOD
        elif self.state == GOOD:
            if self.t_diff > 1.0:
                elapsedTime = time.time() - self.start
                print(Message(self.name + " stalled out after running for " + time.strftime("%H:%M:%S", time.gmtime(elapsedTime)), MSG_ERROR))
                self.state = STALLED
            # do outlier checking
            elif self.is_outlier(val, fields):
                self.state = OUTLIER
                self.outlier_start_time = t
        elif self.state == STALLED:
            if self.t_diff < 1.0 and not self.is_outlier(val, fields):
                self.state = GOOD
                print(Message(self.name + " recovered", MSG_INFO))
            elif self.t_diff < 1.0 and self.is_outlier(val, fields):
                self.state = OUTLIER
                self.outlier_start_time = t
        elif self.state == OUTLIER:
            if not self.is_outlier(val, fields) and (t - self.outlier_start_time) < 1.0:
                print(Message(self.name + " recovered", MSG_INFO))
                self.state = GOOD
            elif self.t_diff > 1.0:
                elapsedTime = time.time() - self.start
                print(Message(self.name + " stalled out after running for " + time.strftime("%H:%M:%S", time.gmtime(elapsedTime)), MSG_ERROR))
                self.state = STALLED
            elif (t - self.outlier_start_time) > MAX_OUTLIER_DURATION:
                self.state = ERROR
                elapsedTime = time.time() - self.start
                timeString = time.strftime("%H:%M:%S", time.gmtime(elapsedTime))
                durationString = time.strftime("%S", time.gmtime(t - self.outlier_start_time))
                print(Message(self.name + " detected an outlier after running for " + timeString + ". Outlier period lasted for " + durationString + " seconds", MSG_ERROR))

        # perform state actions
        # don't add new values to the dataset while in the outlier state
        if self.state != OUTLIER:
            # update standard deviation and mean before the new values are added
            # this way, if the new value is an outlier, it will be easier to detect because it has not skewed our statistics
            if self.check_for_outliers and len(self.data['val']) > 5:
                # index for standard deviation starts at 0 if total dataset size is less than sample size
                # otherwise find the standard deviation of the last STD_SAMPLE_SIZE points
                start_index = 0 if (len(self.data['val']) < STD_SAMPLE_SIZE) else -STD_SAMPLE_SIZE
                arr = numpy.array(self.data['val'][start_index:])
                self.std = numpy.std(arr, axis=0)
                self.mean = numpy.mean(arr, axis=0)
                self.lower_bound = self.mean - Z * self.std
                self.upper_bound = self.mean + Z * self.std

            if fields is not None:
                val = [getattr(val, field) for field in fields]
            elif not isinstance(val, list):
                val = [val]
            elif isinstance(val,list):
                val = val[:8]
            self.max = [max(internal, new) for internal, new in zip(self.max, val)]
            self.min = [min(internal, new) for internal, new in zip(self.max, val)]
            self.data['t'].append(t)
            self.data['val'].append(val)

            if len(self.data['val']) > 10240:
                self.data['val'].pop(0)
                self.data['t'].pop(0)
        



MAX_LOOP_TIME_US = 1000
MAX_ERROR_COUNT = 3

gitHashCmd = "git rev-parse --short HEAD"
gitBranchCmd = "git branch"

class Tester():
    def __init__(self):
        self.acc = Stats(3, 'acc')
        self.gyro = Stats(3, 'gyro')
        self.mag = Stats(3, 'mag')
        self.att = Stats(4, 'att')
        self.omega = Stats(3, 'omega')
        # self.airspeed = Stats(1, 'airspeed')
        # self.baro = Stats(1, 'baro')
        # self.output = Stats(8, 'output')
        # self.rc = Stats(8, 'rc')
        self.status = Stats(2, 'status', check_outliers=False)

        self.stats_list = [key for key in self.__dict__.keys() if "__" not in key]

        self.error_list = { 'stat' : [], 'message' : []}
        self.error_count = 0

        self.last_time = time.time()
        print(CLEAR_SCREEN, end='')
        print("===========  ROSFLIGHT HARDWARE CONTINUOUS INTEGRATION TEST ===========\n\n")
        print(Message("Start Test", MSG_INFO))

        self.run()


    def imu_callback(self, msg):
        t = msg.header.stamp.to_sec()
        self.acc.update(msg.linear_acceleration, t, fields=['x', 'y', 'z'])
        if hasattr(self, 'acc'): self.gyro.update(msg.angular_velocity, t, fields=['x', 'y', 'z'])

    def mag_callback(self, msg):
        t = msg.header.stamp.to_sec()
        if hasattr(self, 'mag'): self.mag.update(msg.magnetic_field, t, fields=['x','y','z'])

    def att_callback(self, msg):
        t = msg.header.stamp.to_sec()
        if hasattr(self, 'att'): self.att.update(msg.attitude, t, fields=['w','x','y','z'])
        if hasattr(self, 'omega'): self.omega.update(msg.angular_velocity, t, fields=['x', 'y', 'z']) # 

    def baro_callback(self, msg):
        t = msg.header.stamp.to_sec()
        if hasattr(self, 'baro'): self.baro.update([msg.pressure], t)

    def airspeed_callback(self, msg):
        t = msg.header.stamp.to_sec()
        if hasattr(self, 'airspeed'): self.airspeed.update(msg.differential_pressure, t)

    def output_callback(self, msg):
        t = msg.header.stamp.to_sec()
        if hasattr(self, 'output'): self.output.update(list(msg.values), t)

    def rc_callback(self, msg):
        t = msg.header.stamp.to_sec()
        if hasattr(self, 'rc'): self.rc.update(list(msg.values), t)

    def status_callback(self, msg):
        t = msg.header.stamp.to_sec()
        if hasattr(self, 'status'): self.status.update(msg, t, fields=['num_errors', 'loop_time_us'])

    def print_progress(self):
        if not hasattr(self, 'start_time'):
            self.start_time = time.time()
            self.progress_index = 1
        progress_indicator = ['_', 'o', 'O', '0', 'O', 'o']
        if time.time() > (self.start_time + 0.12 * self.progress_index):
            self.progress_index += 1
            print(END + '%s%c%s' % (KGRN, progress_indicator[self.progress_index % len(progress_indicator)], RST),
                  end='\r')

    def got_msg(self, type):
        if hasattr(self, type) and len(getattr(self, type).data['val']) > 0:
            return True
        else:
            return False

    def print_status(self, type):
        if self.got_msg(type):
            print(RST+CLEAR, end='')
            string = type + "\r" + GO_FORWARD(8) + " -- | dt = {:10.6f} \t| ["
            values = [getattr(self,type).t_diff]
            for i, val in enumerate(getattr(self, type).data['val'][-1]):
                string += "{:10.4f}"
                values.append(val)
                if i != len(getattr(self, type).data['val'][-1]) -1:
                    string += ", "
            string += "]"
            # string += " | std:" + str(getattr(self,type).std)

            # # print boundary values
            # string += " | bounds: [ "

            # # lower bound
            # for i, val in enumerate(getattr(self, type).lower_bound):
            #     string += "{:5.4f}"
            #     values.append(val)
            #     if i != len(getattr(self, type).data['val'][-1]) -1:
            #         string += ", "
            # string += " ]"
            
            # # upper bound
            # string += "   [ "
            # for i, val in enumerate(getattr(self, type).lower_bound):
            #     string += "{:5.4f}"
            #     values.append(val)
            #     if i != len(getattr(self, type).data['val'][-1]) -1:
            #         string += ", "
            # string += " ]"

            # range = " | Bounds check: [ "
            # for i, (val, upper, lower) in enumerate(zip(getattr(self, type).last_val, getattr(self, type).upper_bound, getattr(self, type).lower_bound)):
            #     if val > upper:
            #         range += "over range"
            #     elif val < upper and val > lower:
            #         range += "in range"
            #     else:
            #         range += "under range"
            #     if i != len(getattr(self, type).last_val) - 1:
            #         range += ", "
            # range += " ]"
            # string += range

            string += " | State: %d" % getattr(self, type).state

            print(string.format(*values), end='\n')
            return 1
        else:
            return 0
    
    def send_email(self, stat, message):
        # # read email credentials from the credentials file
        # credentials = open('credentials', 'r')
        # email = credentials.readline()
        # email = email.rstrip() # remove the trailing \n
        # password = credentials.readline()
        # credentials.close()

        # server = smtplib.SMTP('smtp.gmail.com', 587)
        # server.ehlo()
        # server.starttls()
        # server.ehlo()

        # server.login(email, password)

        # fromaddr = email
        # toaddr = "cameron.mcquinn@gmail.com"
        # msg = MIMEMultipart()
        # msg['From'] = fromaddr
        # msg['To'] = toaddr
        # msg['Subject'] = "Rosflight Hardware CI Failed"
        elapsedTime = time.gmtime(time.time() - getattr(self, stat).start)
        # commitHash = subprocess.check_output(gitHashCmd.split())
        # commitHash = commitHash.rstrip() # remove trailing \n
        # branchCmdOutput = subprocess.check_output(gitBranchCmd.split())
        # currentBranchMarker = "* "
        # startPos = branchCmdOutput.find(currentBranchMarker) + len(currentBranchMarker)
        # endPos = branchCmdOutput.find("\n")
        # branchName = branchCmdOutput[startPos:endPos].rstrip()
        print(CLEAR_SCREEN, end='')
        print("===========  ROSFLIGHT HARDWARE CONTINUOUS INTEGRATION TEST ===========\n\n")
        body = stat + " " + message + " after running for " + time.strftime("%H:%M:%S", elapsedTime) + ".  "
        body += "\n"
        values = []
        
        body += "Mean: [ "
        for i, val in enumerate(getattr(self, stat).mean):
            body += "{:8.6f}"
            values.append(val)
            if i != len(getattr(self, stat).mean) - 1:
                body += ", "
        body += " ]\n"

        body += "Upper bound:  [ "
        for i, val in enumerate(getattr(self, stat).upper_bound):
            body += "{:8.6f}"
            values.append(val)
            if i != len(getattr(self, stat).upper_bound) - 1:
                body += ", "
        body += " ]\n"

        body += "Last value:   [ "
        for i, val in enumerate(getattr(self, stat).last_val):
            body += "{:8.6f}"
            values.append(val)
            if i != len(getattr(self, stat).last_val) -1:
                body += ", "
        body += " ]\n"

        range = "Bounds check: [ "
        for i, (val, upper, lower) in enumerate(zip(getattr(self, stat).last_val,getattr(self, stat).upper_bound,getattr(self, stat).lower_bound)):
            strlen = len("{:8.6f}".format(val))
            if val > upper:
                range += "{:{width}}".format("over", width=strlen)
            elif val < upper and val > lower:
                range += "{:{width}}".format("in range", width=strlen)
            else:
                range += "{:{width}}".format("under", width=strlen)
            if i != len(getattr(self, stat).last_val) - 1:
                range += ", "
        range += " ]\n"
        body += range

        body += "Lower bound:  [ "
        for i, val in enumerate(getattr(self, stat).lower_bound):
            body += "{:8.6f}"
            values.append(val)
            if i != len(getattr(self, stat).lower_bound) - 1:
                body += ", "
        body += " ]\n"

        print(body.format(*values), end='\n')
        # body += "Rosflight commit " + commitHash + " on branch " + branchName + ".  "
        # body += "Now go fix it!"
        # body += "\n\nSincerely,\nthe Rosflight bot"
        # msg.attach(MIMEText(body, 'plain'))

        # # send message
        # text = msg.as_string()
        # server.sendmail(fromaddr, toaddr, text)
        # server.close()
        print("DANGER WILL ROBINSON!!")

    def handle_error(self, stat, message):
        self.error_list['stat'].append(stat)
        self.error_list['message'].append(message)
        error = "Error detected on " + stat
        print(error)
        self.error_count += 1

    def check_for_error(self):
        # check loop time
        if getattr(self, 'status').last_val[1] > MAX_LOOP_TIME_US:
            self.handle_error('status', 'loop_time exceeded %duS' % MAX_LOOP_TIME_US)
            # self.send_email('status', 'loop_time exceeded %duS' % MAX_LOOP_TIME_US)

        # loop through the stats objects and check the state of each one
        for stat in self.stats_list:
            # check for stalled stats
            if getattr(self,stat).state == STALLED:
                # send an email notification that a stall occurred
                # self.send_email(stat, "stalled")
                self.handle_error(stat, "stalled")
            # check for outliers
            elif getattr(self,stat).state == OUTLIER:
                # send an email notification that an outlier was found
                # self.send_email(stat, "detected outlier")
                self.handle_error(stat, "detected outlier")
            

    def render(self):
        if time.time() > self.last_time + 0.03333:
            self.last_time = time.time()
            print("                                                                                                     ", end='')
            self.print_progress() # bouncy thing
            print("\n" + RST + CLEAR, end='\n')
            lines = 3
            lines += self.print_status('acc')
            lines += self.print_status('gyro')
            lines += self.print_status('mag')
            lines += self.print_status('att')
            lines += self.print_status('omega')
            #lines += self.print_status('airspeed')
            #lines += self.print_status('baro')
            #lines += self.print_status('output')
            #lines += self.print_status('rc')
            lines += self.print_status('status')
            print('\n', end='')
            print(RST + CLEAR, end='')
            print(GO_UP(lines), end='\r')

    def run(self):

        rospy.init_node("rosflight_hardware_test")
        self.att_sub = rospy.Subscriber('attitude', Attitude, self.att_callback)
        self.status_sub = rospy.Subscriber('status', Status, self.status_callback)
        self.rc_sub = rospy.Subscriber('rc_raw', RCRaw, self.rc_callback)
        self.output_sub = rospy.Subscriber('output_raw', OutputRaw, self.output_callback)
        self.baro_sub = rospy.Subscriber('baro', Barometer, self.baro_callback)
        self.mag_sub = rospy.Subscriber('mag', MagneticField, self.mag_callback)
        self.acc_sub = rospy.Subscriber('imu/data', Imu, self.imu_callback)
        self.pitot_sub = rospy.Subscriber('airspeed', Airspeed, self.airspeed_callback)

        start_time = time.time()

        while not rospy.is_shutdown() and self.error_count < MAX_ERROR_COUNT:
            # self.check_for_error()
            self.render()

        # print(CLEAR_SCREEN, end='')
        # print("Test terminated after %d errors" % MAX_ERROR_COUNT)

        # print(self.error_list.items())

        # for (stat, message) in zip(self.error_list['stat'], self.error_list['message']):
        #     error = stat + ": " + message
        #     print(error)







if __name__ == '__main__':
    tester = Tester()
