#!/usr/bin/env python
from __future__ import print_function

__author__ = "James Jackson"
__copyright__ = "Copyright 2017, ROSflight"
__license__ = "BSD-3"
__version__ = "0.1"
__maintainer__ = "James Jackson"
__email__ = "superjax08@gmail.com"

import time
import rospy
import smtplib
import numpy
import subprocess
from email.MIMEMultipart import MIMEMultipart
from email.MIMEText import MIMEText
import sys
from sensor_msgs.msg import Imu, MagneticField
from rosflight_msgs.msg import Attitude, Barometer, OutputRaw, RCRaw, Status, Airspeed

RST  = "\x1B[0m"
KRED  = "\x1B[31m"
KMAG  = "\x1B[35m"
KGRN  = "\x1B[32m"
KYEL  = "\x1B[33m"
KBLU  = "\x1B[34m"

BOLD = "\x1B[1m"
UNDL = "\x1B[4m"

CLEAR = "\x1b[2K\r"
UPLINE = "\033[F"
STARTLINE = "\r"
END = "\x1b[200C"
CLEAR_SCREEN = "\033[2J + \033[0;0f"
def GO_UP(x): return "\x1b[" + str(x) + "A"


def GO_FORWARD(x): return "\033[" + str(x) + "C"

MSG_INFO = 1
MSG_WARN = 1
MSG_ERROR = 2
MSG_FATAL = 3

class Message():
    def __init__(self, message, level):
        self.msg = message
        self.lvl = level

    def __str__(self):
        date_string = time.strftime("%Y:%m:%d %H:%M:%S")
        string = RST + "[ " + date_string + " ] - "
        if self.lvl == MSG_INFO:
            string += self.msg
        elif self.lvl == MSG_WARN:
            string += KYEL + self.msg + RST
        elif self.lvl == MSG_ERROR:
            string += KRED + self.msg + RST
        elif self.lvl == MSG_FATAL:
            string += BOLD + KRED + self.msg + RST
        return string

    def __repr__(self):
        return self.__str__()

INIT = 0
GOOD = 1
STALLED = 2
OUTLIER = 3

# dataset size for the standard deviation
STD_SAMPLE_SIZE = 500
Z = 2 # values more than z standard deviations from the mean will be considered outliers

# return values for oulier checking function
NO_OUTLIERS = 0
OUTLIER_DETECTED = 1

class Stats():
    def __init__(self, size, name, check_outliers=True):
        self.max = [0.0 for i in range(size)]
        self.min = [1e9 for i in range(size)]
        self.t_diff = 0.0
        self.last_t = 0.0
        self.last_val = [0.0 for i in range(size)]
        self.data = {'t': [], 'val': []}
        self.name = name
        self.start = time.time()
        self.state = INIT
        self.std_dataset = []
        self.std = [0.0 for i in range(size)] # standard deviation
        self.mean = [0.0 for i in range(size)] # mean value
        self.upper_bound = [0.0 for i in range(size)] # upper bound for acceptible values
        self.lower_bound = [0.0 for i in range(size)] # lower bound for acceptible values
        self.check_for_outliers = check_outliers

        self.m = [0 for i in range(size)]
        self.s = [0 for i in range(size)]
        self.k = [0 for i in range(size)]
        self.var = [0 for i in range(size)]

    # returns true if the last data point recorded is an outlier, false otherwise
    def outlier_check(self):
        retval = NO_OUTLIERS
        for i in range(len(self.last_val)):
            # retval = OUTLIER_DETECTED if abs(self.mean[i] - self.last_val[i]) > self.std[i] * Z else retval
            retval = OUTLIER_DETECTED if self.last_val[i] > self.upper_bound[i] or self.last_val[i] < self.lower_bound[i] else retval
        return retval

    def update(self, val, t, fields=None):

        # update standard deviation and mean before the new values are added
        # this way, if the new value is an outlier, it will be easier to detect because it has not skewed our statistics
        if self.check_for_outliers and len(self.data['val']) > 2:
            # index for standard deviation starts at 0 if total dataset size is less than sample size
            # otherwise find the standard deviation of the last STD_SAMPLE_SIZE points
            start_index = 0 if (len(self.data['val']) < STD_SAMPLE_SIZE) else -STD_SAMPLE_SIZE
            arr = numpy.array(self.data['val'][start_index:])
            self.std = numpy.std(arr, axis=0)
            self.mean = numpy.mean(arr, axis=0)
            self.lower_bound = self.mean - Z * self.std
            self.upper_bound = self.mean + Z * self.std

        if fields is not None:
            val = [getattr(val, field) for field in fields]
        elif not isinstance(val, list):
            val = [val]
        elif isinstance(val,list):
            val = val[:8]
        self.max = [max(internal, new) for internal, new in zip(self.max, val)]
        self.min = [min(internal, new) for internal, new in zip(self.max, val)]
        self.data['t'].append(t)
        self.data['val'].append(val)

        if val != self.last_val:
            self.last_val = val
            self.last_t = t
        self.t_diff = t - self.last_t

        if len(self.data['val']) > 10240:
            self.data['val'].pop(0)
            self.data['t'].pop(0)

        if self.state == INIT:
            print(Message(self.name + " found", MSG_INFO))
            self.state = GOOD
        elif self.state == GOOD and self.t_diff > 1.0:
            elapsedTime = time.time() - self.start
            print(Message(self.name + " stalled out after running for " + time.strftime("%H:%M:%S", time.gmtime(elapsedTime)), MSG_ERROR))
            self.state = STALLED
        # do outlier checking, if it is enabled
        elif self.state == GOOD and self.check_for_outliers == True and len(self.data['val']) > 5 and self.outlier_check() == OUTLIER_DETECTED:
            elapsedTime = time.time() - self.start
            print(Message(self.name + " detected an outlier after running for " + time.strftime("%H:%M:%S", time.gmtime(elapsedTime)), MSG_ERROR))
            self.state = OUTLIER
        elif self.state == STALLED and self.t_diff < 1.0:
            print(Message(self.name + " recovered", MSG_INFO))
            self.state = GOOD


MAX_LOOP_TIME_US = 1000

gitHashCmd = "git rev-parse --short HEAD"
gitBranchCmd = "git branch"

class Tester():
    def __init__(self):
        self.acc = Stats(3, 'acc')
        self.gyro = Stats(3, 'gyro')
        self.mag = Stats(3, 'mag')
        self.att = Stats(4, 'att')
        self.omega = Stats(3, 'omega')
        # self.airspeed = Stats(1, 'airspeed')
        self.baro = Stats(1, 'baro')
        # self.output = Stats(8, 'output')
        # self.rc = Stats(8, 'rc')
        self.status = Stats(2, 'status', check_outliers=False)

        self.stats_list = [key for key in self.__dict__.keys() if "__" not in key]

        self.error = False

        self.last_time = time.time()
        print(CLEAR_SCREEN, end='')
        print("===========  ROSFLIGHT HARDWARE CONTINUOUS INTEGRATION TEST ===========\n\n")
        print(Message("Start Test", MSG_INFO))

        self.run()


    def imu_callback(self, msg):
        t = msg.header.stamp.to_sec()
        self.acc.update(msg.linear_acceleration, t, fields=['x', 'y', 'z'])
        if hasattr(self, 'acc'): self.gyro.update(msg.angular_velocity, t, fields=['x', 'y', 'z'])

    def mag_callback(self, msg):
        t = msg.header.stamp.to_sec()
        if hasattr(self, 'mag'): self.mag.update(msg.magnetic_field, t, fields=['x','y','z'])

    def att_callback(self, msg):
        t = msg.header.stamp.to_sec()
        if hasattr(self, 'att'): self.att.update(msg.attitude, t, fields=['w','x','y','z'])
        if hasattr(self, 'omega'): self.omega.update(msg.angular_velocity, t, fields=['x', 'y', 'z']) # 

    def baro_callback(self, msg):
        t = msg.header.stamp.to_sec()
        if hasattr(self, 'baro'): self.baro.update([msg.pressure], t)

    def airspeed_callback(self, msg):
        t = msg.header.stamp.to_sec()
        if hasattr(self, 'airspeed'): self.airspeed.update(msg.differential_pressure, t)

    def output_callback(self, msg):
        t = msg.header.stamp.to_sec()
        if hasattr(self, 'output'): self.output.update(list(msg.values), t)

    def rc_callback(self, msg):
        t = msg.header.stamp.to_sec()
        if hasattr(self, 'rc'): self.rc.update(list(msg.values), t)

    def status_callback(self, msg):
        t = msg.header.stamp.to_sec()
        if hasattr(self, 'status'): self.status.update(msg, t, fields=['num_errors', 'loop_time_us'])

    def print_progress(self):
        if not hasattr(self, 'start_time'):
            self.start_time = time.time()
            self.progress_index = 1
        progress_indicator = ['_', 'o', 'O', '0', 'O', 'o']
        if time.time() > (self.start_time + 0.12 * self.progress_index):
            self.progress_index += 1
            print(END + '%s%c%s' % (KGRN, progress_indicator[self.progress_index % len(progress_indicator)], RST),
                  end='\r')

    def got_msg(self, type):
        if hasattr(self, type) and len(getattr(self, type).data['val']) > 0:
            return True
        else:
            return False

    def print_status(self, type):
        if self.got_msg(type):
            print(RST+CLEAR, end='')
            string = type + "\r" + GO_FORWARD(8) + " -- | dt = {:10.4f} \t| ["
            values = [getattr(self,type).t_diff]
            for i, val in enumerate(getattr(self, type).data['val'][-1]):
                string += "{:10.4f}"
                values.append(val)
                if i != len(getattr(self, type).data['val'][-1]) -1:
                    string += ", "
            string += "]"
            # string += " | std:" + str(getattr(self,type).std)

            # print boundary values
            string += " | bounds: [ "

            # lower bound
            for i, val in enumerate(getattr(self, type).lower_bound):
                string += "{:5.2f}"
                values.append(val)
                if i != len(getattr(self, type).data['val'][-1]) -1:
                    string += ", "
            string += " ]"
            
            # upper bound
            string += "   [ "
            for i, val in enumerate(getattr(self, type).lower_bound):
                string += "{:5.2f}"
                values.append(val)
                if i != len(getattr(self, type).data['val'][-1]) -1:
                    string += ", "
            string += " ]"

            print(string.format(*values), end='\n')
            return 1
        else:
            return 0
    
    def send_email(self, stat, message):
        # # read email credentials from the credentials file
        # credentials = open('credentials', 'r')
        # email = credentials.readline()
        # email = email.rstrip() # remove the trailing \n
        # password = credentials.readline()
        # credentials.close()

        # server = smtplib.SMTP('smtp.gmail.com', 587)
        # server.ehlo()
        # server.starttls()
        # server.ehlo()

        # server.login(email, password)

        # fromaddr = email
        # toaddr = "cameron.mcquinn@gmail.com"
        # msg = MIMEMultipart()
        # msg['From'] = fromaddr
        # msg['To'] = toaddr
        # msg['Subject'] = "Rosflight Hardware CI Failed"
        # elapsedTime = time.gmtime(time.time() - getattr(self, stat).start)
        # commitHash = subprocess.check_output(gitHashCmd.split())
        # commitHash = commitHash.rstrip() # remove trailing \n
        # branchCmdOutput = subprocess.check_output(gitBranchCmd.split())
        # currentBranchMarker = "* "
        # startPos = branchCmdOutput.find(currentBranchMarker) + len(currentBranchMarker)
        # endPos = branchCmdOutput.find("\n")
        # branchName = branchCmdOutput[startPos:endPos].rstrip()
        # body = stat + " " + message + " after running for " + time.strftime("%H:%M:%S", elapsedTime) + ".  "
        # body += "Rosflight commit " + commitHash + " on branch " + branchName + ".  "
        # body += "Now go fix it!"
        # body += "\n\nSincerely,\nthe Rosflight bot"
        # msg.attach(MIMEText(body, 'plain'))

        # # send message
        # text = msg.as_string()
        # server.sendmail(fromaddr, toaddr, text)
        # server.close()
        print("DANGER WILL ROBINSON!!")

    def check_for_error(self):
        # check loop time
        if getattr(self, 'status').last_val[1] > MAX_LOOP_TIME_US:
            self.error = True
            self.send_email('status', 'loop_time exceeded %duS' % MAX_LOOP_TIME_US)

        # check for stalled stats
        # loop through the stats objects and check the state of each one
        for stat in self.stats_list:
            if getattr(self,stat).state == STALLED:
                # send an email notification that a stall occurred
                self.send_email(stat, "stalled")
                self.error = True

        # check for outliers
        for stat in self.stats_list:
            if getattr(self,stat).state == OUTLIER:
                # send an email notification that a stall occurred
                self.send_email(stat, "detected outlier")
                self.error = True

    def render(self):
        if time.time() > self.last_time + 0.03333:
            self.last_time = time.time()
            print("                                                                                                     ", end='')
            self.print_progress() # bouncy thing
            print("\n" + RST + CLEAR, end='\n')
            lines = 3
            lines += self.print_status('acc')
            lines += self.print_status('gyro')
            lines += self.print_status('mag')
            lines += self.print_status('att')
            lines += self.print_status('omega')
            #lines += self.print_status('airspeed')
            lines += self.print_status('baro')
            #lines += self.print_status('output')
            #lines += self.print_status('rc')
            lines += self.print_status('status')
            print('\n', end='')
            print(RST + CLEAR, end='')
            print(GO_UP(lines), end='\r')

    def run(self):

        rospy.init_node("rosflight_hardware_test")
        self.att_sub = rospy.Subscriber('attitude', Attitude, self.att_callback)
        self.status_sub = rospy.Subscriber('status', Status, self.status_callback)
        self.rc_sub = rospy.Subscriber('rc_raw', RCRaw, self.rc_callback)
        self.output_sub = rospy.Subscriber('output_raw', OutputRaw, self.output_callback)
        self.baro_sub = rospy.Subscriber('baro', Barometer, self.baro_callback)
        self.mag_sub = rospy.Subscriber('mag', MagneticField, self.mag_callback)
        self.acc_sub = rospy.Subscriber('imu/data', Imu, self.imu_callback)
        self.pitot_sub = rospy.Subscriber('airspeed', Airspeed, self.airspeed_callback)

        start_time = time.time()

        while not rospy.is_shutdown() and not self.error:
            self.check_for_error()
            self.render()







if __name__ == '__main__':
    tester = Tester()